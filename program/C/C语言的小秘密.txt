C语言的那些小秘密之const修饰符
或许还有不少人对于const修饰符理解的并不深刻，都只是停留在一个比较浅的层面上，仅仅是在读别人代码的时候看到了const修饰符的使用，自己的写代码的过中从未使用过，所以自然对于const修饰符比较陌生。那么到底什么是const修饰符，我们在自己编写C语言代码的过程中又该如何有效的使用const修饰符呢，现在让我们来学习下const修饰符的使用。
const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，即就是说其所修饰的对象为常量。当你代码中想要设法阻止一个变量被改变，那么这个时候可以选择使用const关键字。在你给一个变量加上const修饰符的同时，通常需要对它进行初始化，在之后的程序中就不能再去改变它。

可能有的人会有一个疑问，我们不是有在C中有预处理指令#define VariableName VariableValue 可以很方便地进行值替代，干嘛还要引入const修饰符呢？！这是因为预处理语句虽然可以很方便的进行值得替代，但它有个比较致命的缺点，即预处理语句仅仅只是简单值替代，缺乏类型的检测机制。这样预处理语句就不能享受C编译器严格类型检查的好处，正是由于这样，使得它的使用存在着一系列的隐患和局限性。

在讲解const修饰符之前，我们在此首先给出const修饰符的几个典型作用：

1.   const类型定义：指明变量或对象的值是不能被更新,引入目的是为了取代预编译指令

2.   可以保护被修饰的东西，防止意外的修改，增强程序的健壮性；

3.   编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。

4.    可以节省空间，避免不必要的内存分配。

一、const修饰符在函数体内修饰局部变量。
 const int n=5；和 int const n=5；
是等价的。我们在编程的过程中一定要清楚的知道const修饰的对象是谁，在这里修饰的是n，和int没有关系。const 要求他所修饰的对象为常量，不能被改变，同时也不能够被赋值，所以下面这样的写法是错误的。
const int n;
n=0;
对于上面的情况是比较容易理解的，但是当const与指针一起使用时，就容易让人感到迷惑。例如，下面我们来看看一个p和q的声明：
 const int *p;
 int const *q;
看了上面的代码可能有人会觉得 const int *p;表示的是const int类型的指针（const直接修饰int），而 int const *q;表示的是int类型的const指针（const直接修饰指针）。实际上，在上面的声明中p和q都被声明为const int类型的指针。而int类型的const指针应该这样声明：
 int * const r= &n;
以上的p和q都是指向const int类型的指针，也就是说，你在以后的程序里不能改变*p的值。而r是一个const指针，它在声明的时候被初始化指向变量n（即r=&n；）之后，r的值将不再允许被改变，但*r的值可以改变。在此对于判断const的修饰对象给出一种常使用的方法，我们以*为界线，如果const位于*的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量；如果const位于*的右侧，const就是修饰指针本身，即指针本身是常量。

还是给个代码来加深下大家的印象吧。

#include <stdio.h>

int main(int argc, char* argv[]){
 int ss=9;
 int * const r= &ss;
 printf("%d\n",*r);
 printf("%d\n",ss);
 *r=100;
 printf("%d\n",*r);
 printf("%d\n",ss);

    return 0;
}

运行结果如下：

简单的来分析下吧，因为r指向的是ss的地址，所以修改r指向的地址单元的值的同时ss的值也随之变化。

结合上述两种const修饰的情况，我们现在应该可以完成如何声明一个指向const int类型的const指针，如下：

const int * const r=&ss;

这个时候我们既不能修改*r的值也不能修改r的值。

接下来看看const用于修饰常量静态字符串，例如：例如：

const char* str="fdsafdsa";

如果没有const的修饰，我们可能会在后面有意无意的写str[4]='x'这样的语句，这样会导致对只读内存区域的赋值，然后程序会立刻异常终止。有了const，这个错误就能在程序被编译的时候就立即检查出来，这就是const的好处。让逻辑错误在编译期被发现。

二、const在函数声明时修饰参数

void *memmove( void* dest, const void* src, size_t count ); 这是标准库中的一个函数，在头文件#include <string.h>中声明，其功能为由src所指内存区域复制count个字节到dest所指内存区域。用于按字节方式复制字符串（内存）。它的第一个参数，是将字符串复制到哪里去(dst),是目的地，这段内存区域必须是可写。它的第二个参数，是要将什么样的字符串复制出去，我们对这段内存区域只做读取，不写。于是，我们站在这个函数自己的角度来看，src 这个指针，它所指向的内存内所存储的数据在整个函数执行的过程中是不变。于是src所指向的内容是常量。于是就需要用const修饰。另外需要强调的一点就是src和dest所指内存区域可以重叠，但复制后dest内容会被更改。函数返回指向dest的指针。

例如，我们这里这样使用它。

#include <stdio.h> 
#include <string.h>

int main(int argc, char* argv[])
{
 const char* str="hello";
 char buf[10];
 memmove(buf,str,6); 
 printf("%s\n",buf);

    return 0;
}

运行结果如下：

如果我们反过来写，memmove(str,buf,6);那么编译器一定会报错。事实是我们经常会把各种函数的参数顺序写反。事实是编译器在此时帮了我们大忙。如果编译器静悄悄的不报错，即在函数声明void *memmove( void* dest, const void* src, size_t count ); 处去掉const即可，那么这个程序在运行的时候一定会崩溃。这里还要说明的一点是在函数参数声明中const一般用来声明指针而不是变量本身。例如，上面的size_t len,在函数实现的时候可以完全不用更改len的值，那么是否应该把len也声明为常量呢？可以，可以这么做。我们来分析这么做有什么优劣。如果加了const,那么对于这个函数的实现者，可以防止他在实现这个函数的时候修改不需要修改的值(len),这样很好。但是对于这个函数的使用者，

1.饰符号毫无意义，我们可以传递一个常量整数或者一个非常量整数过去，反正对方获得的只是我们传递的一个copy。
2实现。我不需要知道你在实现这个函数的时候是否修改过len的值。

所以，const一般只用来修饰指针。再看一个复杂的例子
int execv(const char *path, char *const argv[]);
着重看后面这个，argv.它代表什么。如果去掉const,我们可以看出char * argv[]，argv是一个数组，它的每个元素都是char *类型的指针。如果加上const.那么const修饰的是谁呢？修饰的是一个数组，argv[]意思就是说这个数组的元素是只读的。那么数组的元素的是什么类型呢？是char *类型的指
针.也就是说指针是常量，而它指向的数据不是。于是
argv[1]=NULL; //非法
argv[0][0]='a'; //合法

三、const作为全局变量
在程序中，我们要尽可能少的使用全局变量。因为其作用域是全局，所以程序范围内都可以修改它的值，从而导致了全局变量不能保证值的正确性，如果出现错误非常难以发现。如果在多线程中使用全局变量，你的程序将会错的一塌糊涂。多线程会修改另一个线程使用的全局变量的值，如果不注意，一旦出错后果不堪设想。所以在这种情况下万不得意不要使用全局变量。我们要尽可能多的使用const。如果一个全局变量只在本文件中使用，那么用法和前面所说的函数局部变量没有什么区别。如果它要在多个文件间共享，那么就牵扯到一个存储类型的问题。

有两种方式。

1.用extern
例如
/* pi.h */
extern const double pi;
/* pi.c */
const double pi=3.14;
然后其他需要使用pi这个变量的，包含pi.h

#include pi.h

或者，自己把那句声明复制一遍就好。这样做的结果是，整个程序链接完后，所有需要使用pi这个变量的共享一个存储区域。

2.使用static,静态外部存储类
/* constant.h */
static const double pi=3.14;

需要使用这个变量的*.c文件中，必须包含这个头文件。前面的static一定不能少。否则链接的时候会报告说该变量被多次定义。这样做的结果是，每个包含了constant.h的*.c文件，都有一份该变量自己的copy,该变量实际上还是被定义了多次，占用了多个存储空间，不过在加了static关键字后，解决了文件间重定义的冲突。坏处是浪费了存储空间，导致链接完后的可执行文件变大。通常来说，对于存储空间字节的变化不是太大的情况下，不是问题。好处是，你不用关心这个变量是在哪个文件中被初始化的。

下面再来看看一段代码：
#include <stdio.h>

int main(){
 const int a=12;
 const int *p=&a;           // 这个是指向常量的指针，指针指向一个常量
 p++;                               //可以指针可以自加、自减
 p--;                                  //合法

 int const *q=&a;           // 这个和上面const int *p=&a;是一个意思 
 int b=12;

 int * const r=&b;           //这个就是常量指针(常指针)，不能自加、自减,并且要初始化
 //r++;                               //编译出错 

 const int * const t=&b; //这个就是指向常量的常指针,并且要初始化，用变量初始化

 //t++;                                //编译出错
 p=&b;                              //const指针可以指向const和非const对象 
 q=&b;                              //合法

 return 0;
}

为了便于代码的阅读理解，在此就直接在代码后面加注释，就不在这儿做过多的讲解了。

综上所述，const 的好处，是引入了常量的概念，让我们不要去修改不该修改的内存。直接的作用就是让更多的逻辑错误在编译期被发现。所以我们要尽可能的多使用const。以上内容难免有错，如果错误，请纠正！如需转载，请注明出处！

动态数组
很多人在编写C语言代码的时候很少使用动态数组，不管什么情况下通通使用静态数组的方法来解决，在当初学习C语言的时候我就是一个典型的例子，但是现在发现这是一个相当不好的习惯，甚至可能导致编写的程序出现一些致命的错误。尤其对于搞嵌入式的人来所，嵌入式系统的内存是宝贵的，内存是否高效率的使用往往意味着嵌入式设备是否高质量和高性能，所以高效的使用内存对我们来说是很重要的。那么我们在自己编写C语言代码的时候就应该学会使用动态数组，这也就是我这篇博客要给大家讲的，我尽我所能的用一些简单的代码来讲解动态数组，希望我所讲的对你有所帮助。

那么我们首先来看看什么是动态数组，动态数组是相对于静态数组而言，从“动”字我们也可以看出它的灵活性，静态数组的长度是预先定义好的，在整个程序中，一旦给定大小后就无法改变。而动态数组则不然，它可以随程序需要而重新指定大小。动态数组的内存空间是从堆动态分配的。是通过执行代码而为其分配存储空间。当程序执行到我们编写的分配语句时，才为其分配。对于静态数组，其创建非常方便，使用完也无需释放，要引用也简单，但是创建后无法改变其大小是其致命弱点！对于动态数组，其创建麻烦，使用完必须由程序员自己释放，否则将会引起内存泄露。但其使用非常灵活，能根据程序需要动态分配大小。所以相对于静态数组的来说我们对于使用动态数组有很大的自由度。

在创建动态数组的过程中我们要遵循一个原则，那就是在创建的时候从外层往里层，逐层创建；而释放的时候从里层往外层，逐层释放。这个话你读了可能理解并不深刻，不过不要急，接下来我们看看两段代码。

一维动态数组的创建：

#include <stdio.h>
#include <stdlib.h>
int main()
{
int n1,i;
int *array;
printf("请输入所要创建的一维动态数组的长度：");
scanf("%d",&n1);
array=(int*)calloc(n1,sizeof(int));
for(i=0;i<n1;i++)
{
 printf("%d\t",array[i]);
}
printf("\n");
for(i=0;i<n1;i++)
{
 array[i]=i+1;
 printf("%d\t",array[i]);
}
 free(array);//释放第一维指针 
return 0;
}

运行结果为：
特此说明：在以后的运行结果部分，我均会附上文字结果，以防图片打开失败。

请输入所要创建的一维动态数组的长度：4
0       0       0       0
1       2       3       4       Press any key to continue

在此我使用的是calloc()函数来分配的，同时也使用两个for语句来打印数组元素，我们发现第一个打印输出的数组元素值均为0，在此也是为了加深读者对于calloc()函数的印象我特地使用了它来分配，如果对于calloc()、malloc()、realloc()函数的区别还是很清楚的读者可以去看看我的另外一篇博客------C语言的那些小秘密之内存分配。

二维数组的创建：

#include <stdio.h> 
#include <stdlib.h> 
int main() 
{ 
int n1,n2; 
int **array,i,j; 
printf("请输入所要创建的动态数组的第一维长度：");
scanf("%d",&n1);
printf("请输入所要创建的动态数组的第二维长度：");
scanf("%d",&n2); 
array=(int**)malloc(n1*sizeof(int*)); //第一维 
for(i=0;i<n1; i++) 
{ 
array[i]=(int*)malloc(n2* sizeof(int));//第二维 
}
for(i=0;i<n1;i++)
{
for(j=0;j<n2;j++) 
{ 
array[i][j]=i*n2+j+1; 
printf("%d\t",array[i][j]); 
} 
printf("\n");
}
for(i=0;i<n1;i++) 
{ 
free(array[i]);//释放第二维指针 
} 
free(array);//释放第一维指针 
return 0; 
}

运行结果为：

 请输入所要创建的动态数组的第一维长度：3
请输入所要创建的动态数组的第二维长度：3
1       2       3
4       5       6
7       8       9
Press any key to continue

有了上面的代码我们再来说动态数组的建立就简单了，以二维为例，先说创建，还记得我们上面说的创建的原则嘛：从外层往里层，逐层创建。

array=(int**)malloc(n1*sizeof(int*)); //第一维

以上是我们创建二维动态数组的最外层，创建好了最外层那么我们接下来就是要创建次外层了。

array[i]=(int*)malloc(n2* sizeof(int));//第二维

在创建次外层的过程中我们使用了一个for喜欢语句，千万别忘了使用for循环语句，这是绝大多数人的一个易错点。

创建好了接下来我们该讲到释放了，而释放的时候从里层往外层，逐层释放。刚刚与我们上面的创建相反，在以上代码中我们首先使用了下面一个for循环来释放里层。

for(i=0;i<n1;i++) 
{ 
free(array[i]);//释放第二维指针 
}

在通过以下语句来释放外层。
free(array);//释放第一维指针

如果出现多维的情况怎么做呢，我们接下来再来看看一个三维动态数组的创建和释放，以加深下读者的印象。代码如下：

#include <stdlib.h> 
#include <stdio.h> 
int main() 
{ 
int n1,n2,n3; 
int ***array; 
int i,j,k; 
printf("请输入所要创建的动态数组的第一维长度：");
scanf("%d",&n1); 
printf("请输入所要创建的动态数组的第二维长度：");
scanf("%d",&n2); 
printf("请输入所要创建的动态数组的第三维长度：");
scanf("%d",&n3); 
array=(int***)malloc(n1*sizeof(int**));//第一维 
for(i=0; i<n1; i++) 
{ 
array[i]=(int**)malloc(n2*sizeof(int*)); //第二维 
for(j=0;j<n2;j++) 
{ 
array[i][j]=(int*)malloc(n3*sizeof(int)); //第三维 
} 
} 
for(i=0;i<n1;i++)
{
for(j=0;j<n2;j++)
{
for(k=0;k<n3;k++) 
{ 
array[i][j][k]=i+j+k+1; 
printf("%d\t",array[i][j][k]); 
} 
printf("\n");
}
printf("\n");
}
for(i=0;i<n1;i++) 
{ 
for(j=0;j<n2;j++) 
{ 
free(array[i][j]);//释放第三维指针 
} 
} 
for(i=0;i<n1;i++) 
{ 
free(array[i]);//释放第二维指针 
} 
free(array);//释放第一维指针 
return 0; 
}

运行结果为：
请输入所要创建的动态数组的第一维长度：3
请输入所要创建的动态数组的第二维长度：3
请输入所要创建的动态数组的第三维长度：3
1       2       3
2       3       4
3       4       5

2       3       4
3       4       5
4       5       6

3       4       5
4       5       6
5       6       7

Press any key to continue

看了以上三维动态数组的创建和释放代码以后，我想读者这个时候已经可以自己编写任意维的动态数组了。但是细心的读者可能发现了一个问题，那就是我们所讲的动态数组都是一次性创建好的，如果接下来在使用的过程中我们使用的数组需要扩展或者删减一些不再使用元素该怎么办呢？！接下来我们先看一段关于动态数组扩展的代码，在此以一维动态数组的扩展为例，其它的以此类推。

#include <stdio.h>
#include <stdlib.h>
int main()
{
int*n,*p;
int i,n1,n2;
printf("请输入所要创建的动态数组的长度：");
scanf("%d",&n1); 
n=(int*)calloc(n1,sizeof(int));
printf("请输入所要扩展的动态数组的长度：");
scanf("%d",&n2); 
p=(int*)realloc(n,(n2)*sizeof(int));//动态扩充数组
for(i=0;i<n2;i++)
{
p[i]=i+1;
if(i%5==0)
printf("\n");
printf("%d\t",p[i]);
}
free(p);
return 0;
}

运行结果如下：

请输入所要创建的动态数组的长度：6
请输入所要扩展的动态数组的长度：25

1       2       3       4       5
6       7       8       9       10
11      12      13      14      15
16      17      18      19      20
21      22      23      24      25      Press any key to continue

看了上面的代码读者应该知道如何来扩展动态数组了，可能有的读者对于realloc()函数的使用有些陌生，如果有什么疑惑的话可以参考我之前写的一篇博文------C语言的那些小秘密之内存分配，在此我就不再做过多的讲解了。

接下来如何缩小动态数组。

#include <stdio.h>
#include <stdlib.h>
int main()
{
int*n,*p;
int i,n1,n2;
printf("请输入所要创建的动态数组的长度：");
scanf("%d",&n1); 
n=(int*)calloc(n1,sizeof(int));
for(i=0;i<n1;i++){
n[i]=i+1;
if(i%5==0)
printf("\n");
printf("%d\t",n[i]);
}
printf("\n请输入所要缩小的动态数组的长度：");
scanf("%d",&n2); 
p=(int*)realloc(n,(n2)*sizeof(int));
for(i=0;i<n2;i++){
if(i%5==0)
printf("\n");
printf("%d\t",p[i]);
}
printf("\n");
free(p);
return 0;
}

运行结果为：
请输入所要创建的动态数组的长度：25

1       2       3       4       5
6       7       8       9       10
11      12      13      14      15
16      17      18      19      20
21      22      23      24      25
请输入所要缩小的动态数组的长度：15

1       2       3       4       5
6       7       8       9       10
11      12      13      14      15
Press any key to continue

在这里值得注意的一点就是在缩减动态数组的时候，它是删除了后面的元素，而前面的元素保持不变。在使用realloc()函数的时候要由其注意它的使用规则。

讲到这儿就到了该说结束的时候了，由于本人水平有限，博客中的不妥或错误之处在所难免，殷切希望读者批评指正。同时也欢迎读者共同探讨相关的内容，如果乐意交流的话请留下你宝贵的意见。